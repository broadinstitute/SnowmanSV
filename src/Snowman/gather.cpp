#include "gather.h"
#include <unordered_map>
#include <time.h>
#include <algorithm>
#include <functional>
#include <ctime>
#include <getopt.h>
#include "kseq.h"
#include "api/algorithms/Sort.h"
#include "GenomicRegion.h"
#include "api/BamWriter.h"
#include "workqueue.h"
#include "SnowUtils.h"


#define MAX_TOKENS_PER_LINE 100

KSEQ_INIT(gzFile, gzread)

using namespace std;
using namespace BamTools;

const char* const DELIMITER = ";";
static const char *CONCAT_USAGE_MESSAGE =
"Usage: snowman gather [OPTION] \n\n"
"  Description: Take contigs generated from \"snowman run\" and realign reads, filter and find breakpoints\n"
"\n"
" General options\n"
"  -v, --verbose                        Select verbosity level (0-4). Default: 1 \n"
"  -h, --help                           Display this help and exit\n"
"  -p, --threads                        Use NUM threads to run Snowman. Default: 1\n"
"      --repeat-masker                  Flag to send contigs to RepeatMasker. \n"
"      --blat                           Flag to send contigs to Blat. \n"
"  -t, --tumor-bam                      Tumor BAM to do extra read mapping with. \n"
"  -n, --normal-bam                     Normal BAM to do extra read mapping with \n"
"  -s, --panel-bam                      Panel-of-normals BAM to do extra read mapping with \n"
" Required Input\n"
"  -r, --reads2contig                   A reads2contig BAM produced from snowman run (or -> snowman clean).\n"
"  -b, --contig-bam                     A bam file containing aligned contigs. Produced at end of snowman run\n"
" Optional input"
"  -o, --outdir                         Directory to puth the output files in. Default: ./\n"
"  -d, --discordant-bam                 BAM file generated by snowman containing discorant reads labeled with DC field.\n"
"      --skip-realign                   Skip re-alignment of reads to contigs. Useful if you already generated r2c_final.bam\n"
"      --multiple-map-fasta             Output a fasta file (multiple_map.fa) with the contigs that have multiple mappings to the reference.\n"
"      --no-r2c-matched                 Don't keep the reads around long enough to write to the final r2c_matched.bam. Saves a lot of memory. Default: false"
"  Event Filters\n"
"      --tumor-reads                    Number of tumor split reads required to call an event somatic (0 normal). Default: 3\n"
"      --germline-reads                 Number of total reads (min normal =1) required to call a germline event. Default: 3\n"
"      --max-mapq                       Set the minimum MAPQ for a contigs best MAPQ. Default: 0\n"
"      --min-mapq                       Set the minimum MAPQ for a contigs MAPQ. Default: 0\n"
"      --min-length                     Set the minimum length of a contig. Default 100\n"
"  DISCOVAR options\n"
"      --discovar-acount                Discovar acount file to distinguish between tumor/normal supported contigs. If supplied, finds only tumor-contig breakpoints\n"
"      --discovar-acount-rule           Use only information from the acount file to determine if tumor or normal. Default: offn"
"\n";

namespace opt {
  static unsigned verbose = 1;
  static unsigned numThreads = 1;
  static string outdir = "./";
  static int mapq = 30;
  static unsigned tum = 3;
  static unsigned germ = 3;
  static string tumor_sample = "null";
  static string normal_sample = "null";
  static bool repeat_masker = false;
  static bool blat = false;
  static string discovar_acount = "";
  
  static string contig_bam = "";
  static string r2c_bam = "";

  static string discordant_bam = "";
  static bool no_r2c_matched = false;

  static string tumor_bam = "";
  static string normal_bam = "";
  static string panel_bam = "";

  static bool skip_realign = false;

  static bool discovar_acount_rule = false;
  static bool multiple_map_fasta = false;

  static int max_mapq = 0;
  static int min_mapq = 0;
  static int min_length = 100;
}

enum { 
  OPT_REPEAT = 1,
  OPT_BLAT,
  OPT_TUMOR_READS,
  OPT_NORMAL_READS,
  OPT_SKIP_REALIGN,
  OPT_DISCOVAR_ACOUNT,
  OPT_MULTIPLE_MAP_FASTA,
  OPT_DISCOVAR_ACOUNT_RULE,
  OPT_NO_R2C_MATCHED,
  OPT_MIN_MAPQ,
  OPT_MAX_MAPQ,
  OPT_MIN_LENGTH
};

static const char* shortopts = "hv:p:w:t:n:r:b:o:s:d:";
static const struct option longopts[] = {
  { "help",                    no_argument, NULL, 'h' },
  { "input-directory",         required_argument, NULL, 'i' },
  { "threads (\"processes\")", required_argument, NULL, 'p' },
  { "verbose",                 required_argument, NULL, 'v' },
  { "map-quality",             required_argument, NULL, 'w' },
  { "tumor-reads",             required_argument, NULL, OPT_TUMOR_READS },
  { "germline-reads",          required_argument, NULL, OPT_NORMAL_READS },
  { "outdir",                  required_argument, NULL, 'o' },
  { "contig-bam",              required_argument, NULL, 'b' },
  { "reads2contig",            required_argument, NULL, 'r' },
  { "tumor-bam",               required_argument, NULL, 't' },
  { "normal-bam",              required_argument, NULL, 'n' },
  { "panel-bam",               required_argument, NULL, 's' },
  { "min-mapq",               required_argument, NULL, OPT_MIN_MAPQ },
  { "max-mapq",               required_argument, NULL, OPT_MAX_MAPQ },
  { "min-length",               required_argument, NULL, OPT_MIN_LENGTH },
  { "discordant-bam",               required_argument, NULL, 'd' },
  { "discovar-acount",               required_argument, NULL, OPT_DISCOVAR_ACOUNT },
  { "skip-realign",           no_argument, NULL, OPT_SKIP_REALIGN },
  { "no-r2c-matched",         no_argument, NULL, OPT_NO_R2C_MATCHED },
  { "repeat-masker",           no_argument, NULL, OPT_REPEAT },
  { "blat",                    no_argument, NULL, OPT_BLAT },
  { "multiple-map-fasta",                    no_argument, NULL, OPT_MULTIPLE_MAP_FASTA },
  { "discovar-acount-rule",                    no_argument, NULL, OPT_DISCOVAR_ACOUNT_RULE },
  { NULL, 0, NULL, 0 }
};

static pthread_mutex_t snow_lock;
static ContigMap * contigs_read_in; // step 1
static ContigMap * contigs_realigned; // step 2
static AcountMap * amap;
static DMap * dmap;
static struct timespec start;
static size_t contig_to_realign_size;
static size_t realign_count;

/*typedef IntervalT<string> StringInterval;
typedef IntervalTree<string> SStringTree;
typedef unordered_map<int, SStringTree*> SStringTreeMap;
typedef vector<StringInterval> StringIntervalVector;
typedef unordered_map<int, StringIntervalVector> StringIntervalVectorMap;
*/
//static SStringTreeMap * discmap1;
//static SStringTreeMap * discmap2;

//typedef unordered_map<int, * GenomicTree> GenomicTreeMap;
//static GenomicTreeMap * discordant_tree;

//typedef unordered_map<int, GenomicIntervalVector > GenomicIntervalVectorMap;

void parseXPString(string xp, vector<int> &chr, vector<int> &pos, 
		   vector<int> &mapq, vector<int> &nmvec) { //, vector<string> &vect, string &chr, char &strand, 
//		   int &pos, int &mapq) {

  istringstream iss(xp);
  string token;
  while(getline(iss, token, ';')) {
    string record;
    istringstream iss2(token);
    size_t count = 0;
    while(getline(iss2, record, ',')) {
      if (count==0) {
	//chr.push_back(stoi(record));
      } else if (count==3) {
	mapq.push_back(stoi(record));
      } else if (count==4) {
	nmvec.push_back(stoi(record));
      }
      count++;
    }
  }
  return;

}

void debugContig(string contig, const ContigMap * map, string msg) {
  
  for (ContigMap::const_iterator it = map->begin(); it != map->end(); it++) {
    if (it->second.getContigName() == contig) {
      cout << "CONTIG FOUND HERE AT " << msg << endl;
      if (msg == "contigs_final") {
	ofstream os_allbps("/home/unix/jwala/test.txt", ios::out);
	os_allbps << it->second.printAlignments();
      }
    }
  }
}

bool runConcat(int argc, char** argv) {

  // start the timer
  clock_gettime(CLOCK_MONOTONIC, &start);

  parseConcatOptions(argc, argv);

  bool discovar = opt::discovar_acount != "";
  if (opt::verbose > 0) {
    string repeat_msg = opt::repeat_masker ? "ON" : "OFF";
    string blat_msg = opt::blat ? "ON" : "OFF";
    string realign_msg = opt::skip_realign ? "ON" : "OFF";
    cout << "-- Num threads:       " << opt::numThreads << endl;
    cout << "-- Input contig bam:  " << opt::contig_bam << endl;
    cout << "-- Input r2c bam:     " << opt::r2c_bam << endl;
    cout << "-- Output directory:  " << opt::outdir << endl;
    cout << "-- Send RepeatMasker: " << repeat_msg << endl;
    cout << "-- Send Blat:         " << blat_msg << endl;
    cout << "-- Skip realignment:  " << realign_msg << endl;
    cout << "-- No r2c_matched:    " << (opt::no_r2c_matched ? "ON" : "OFF") << endl;
    cout << "   BAMs for contig validation: " << endl;
    cout << "   --Tumor:  " << opt::tumor_bam << endl;
    cout << "   --Normal: " << opt::normal_bam << endl;
    cout << "   --Panel:  " << opt::panel_bam << endl;
    cout << "   --Discordant:  " << opt::discordant_bam << endl;
    cout << "   Contig filters:  " << endl;
    cout << "   --Min (max) mapq: " << opt::max_mapq << endl;
    cout << "   --Min mapq:       " << opt::min_mapq << endl;
    cout << "   --Min length:     " << opt::min_length << endl;
  }
  if (opt::verbose > 0 && discovar) {
    cout << "RUNNING IN DISCOVAR MODE. ACOUNT FILE: " << opt::discovar_acount << endl;
    if (opt::discovar_acount_rule)
      cout << "---Using only the acount tumor/normal counts to determine contig quality (ignoring read realignment data)" << endl;
  }

  // initialize the mutex
  if (pthread_mutex_init(&snow_lock, NULL) != 0) {
      printf("\n mutex init failed\n");
      return false;
  }

  // read in the discovar acount file if it exists
  amap = new AcountMap();
  if (discovar)
    parseDiscovarAcount();

  // read in the discordant bam structure
  dmap = new DMap();
  if (opt::discordant_bam != "") 
    readDiscordantBam();
  
  // read in contigs
  contigs_read_in = new ContigMap();
  readContigBAM(contigs_read_in);

  // write the FASTA file of contigs containing multiple mappings
  if (opt::multiple_map_fasta)
    writeContigFasta(contigs_read_in);

  // moves from contigs_trim to contigs_realigned
  contigs_realigned = new ContigMap();
  contig_to_realign_size = contigs_read_in->size();
  realign_count = 0;
  realignThreadReads(contigs_read_in);

  // write to a r2c_matched BAM file
  //if (!opt::skip_realign && !opt::discovar_acount_rule && !opt::no_r2c_matched)
  //  writeR2CmatchedBAM(contigs_realigned);

  // add discordant clusters to contigs
  if (opt::discordant_bam != "")
    combineContigsWithDiscordantClusters();
  
  // write the discordant files
  if (opt::discordant_bam != "")
    writeDiscordantBreakpoints();

  // create the fine breakpoint vector
  vector<BPVec> bps; 
  for (ContigMap::const_iterator it = contigs_realigned->begin(); it != contigs_realigned->end(); it++) {
    bps.push_back(it->second.getBreaks());
    //assert(bps.back().size() != 0);

    //debug
    if (bps.back().size() == 0)
      cerr << " bps size = 0 at contig " << it->second.getContigName() << endl;
  }

  // create the breakpoint vector
  BPVec bp_glob; 
  for (ContigMap::const_iterator it = contigs_realigned->begin(); it != contigs_realigned->end(); it++) 
    bp_glob.push_back(it->second.getGlobalBreak());
  if (opt::verbose > 0)
    cout << "...BPs global length: "  << bp_glob.size() << endl;

  assert(bp_glob.size() == bps.size());

  // convert vector of BPVecs to BPVec
  BPVec bp_fine; 
  for (vector<BPVec>::const_iterator it = bps.begin(); it != bps.end(); it++) {
    if (it->size() > 0)
      //for (BPVec::const_iterator jt = it->begin(); jt != it->end(); jt++)
      //	bp_fine.push_back(*jt);
        bp_fine.insert(bp_fine.end(), it->begin(), it->end());
  }
  if (opt::verbose > 0)
    cout << "...BPs fine length: "  << bp_fine.size() << endl;

  assert(bp_fine.size() >= bp_glob.size());

  // sort by location
  sort(bp_fine.begin(), bp_fine.end());
  sort(bp_glob.begin(), bp_glob.end());

  // mark duplicates in vector
  //if (opt::verbose > 0)
  //  cout << "...marking and removing duplicate breaks\n";
  //markDuplicates(bp_fine);
  //markDuplicates(bp_glob);

  // add discordant pairs to breakpoints
  if (opt::discordant_bam != "") {
    //addDiscordantPairsBreakpoints(bp_glob);
    //addDiscordantPairsBreakpoints(bp_fine);
  }

  // send all bps to file
  stringstream out_allbps; out_allbps << opt::outdir << "/allbps.txt";
  ofstream os_allbps(out_allbps.str(), ios::out);
  for (BPVec::const_iterator it = bp_glob.begin(); it != bp_glob.end(); it++) 
    os_allbps << it->toString() << endl;

  // remove duplicates
  //BPVec bp_fine_f;
  //removeDuplicates(bp_fine, bp_fine_f);
  //BPVec bp_glob_f;
  //removeDuplicates(bp_glob, bp_glob_f);
  //cout << "GLOB DEDUP: " << bp_glob.size() << endl;

  // now that you have the breakpoint list, populate events as somatic or germline
  cout << "BPFINE: " << bp_fine.size() << endl;
  cout << "BPglob: " << bp_glob.size() << endl;
  //setBreakSomaticGermline(bp_fine);
  setBreakSomaticGermline(bp_glob);

  // write out the surviving contigs to somatic and germline fasta files
  writeContigs(contigs_realigned);

  // send contigs to RepeatMasker
  if (opt::repeat_masker)
    sendRepeatMasker(contigs_realigned);

  // send contigs to Blat
  if (opt::blat)
    sendBlat(contigs_realigned);

  // print alignments to an ASCII text file
  writeAsciiPlots(contigs_realigned);
  
  // write the breakpoint files
  writeBreakFiles(bp_fine, bp_glob);

  // dump the read alignments to text file for plotting in R
  writeForRPlots(contigs_realigned);

  // write contigs to BAM files
  //writeFinalBams(contigs_realigned);

  // display the run time
  if (opt::verbose > 0) {
    SnowUtils::displayRuntime(start); 
    cout << "\n";
  }

  return true;
}

void parseConcatOptions(int argc, char** argv) {
  bool die = false;

  if (argc < 2) 
    die = true;

  for (char c; (c = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1;) {
    istringstream arg(optarg != NULL ? optarg : "");
    switch (c) {
      case 'p': arg >> opt::numThreads; break;
      case 'h': die = true; break;
      case 'w': arg >> opt::mapq; break;
      case 't': arg >> opt::tumor_bam; break;
      case 'n': arg >> opt::normal_bam; break;
      case 's': arg >> opt::panel_bam; break;
      case 'd': arg >> opt::discordant_bam; break;
      case 'v': arg >> opt::verbose; break;
      case 'o': arg >> opt::outdir; break;
      case 'r': arg >> opt::r2c_bam; break;
      case 'b': arg >> opt::contig_bam; break;
      case OPT_REPEAT : opt::repeat_masker = true; break;
      case OPT_DISCOVAR_ACOUNT_RULE : opt::discovar_acount_rule = true; break;
      case OPT_SKIP_REALIGN : opt::skip_realign = true; break;
      case OPT_BLAT : opt::blat = true; break;
      case OPT_TUMOR_READS : arg >> opt::tum; break;
      case OPT_NORMAL_READS : arg >> opt::germ; break;
      case OPT_DISCOVAR_ACOUNT : arg >> opt::discovar_acount; break;
      case OPT_MULTIPLE_MAP_FASTA : opt::multiple_map_fasta = true; break;
      case OPT_NO_R2C_MATCHED : opt::no_r2c_matched = true; break;
      case OPT_MIN_MAPQ : arg >> opt::min_mapq; break;
      case OPT_MAX_MAPQ : arg >> opt::max_mapq; break;
      case OPT_MIN_LENGTH : arg >> opt::min_length; break;
    }
  }

  // prefere r2c bam if have it
  if (SnowUtils::existTest(opt::r2c_bam) && (SnowUtils::existTest(opt::normal_bam) || SnowUtils::existTest(opt::tumor_bam)) ) {
    cerr << "############################################################################################################" << endl;
    cerr << "r2c bam supplied along with either tumor/normal bam. Assuming r2c is preferred, setting tumor to null"<< endl;
    cerr << "############################################################################################################" << endl;
    //opt::normal_bam = "";
    opt::tumor_bam = "";
  }

  // if filename, convert to directory
  //opt::outdir    = SnowUtils::getDirPath(opt::outdir);

  if(opt::numThreads <= 0) {
    cout << "gather: invalid number of threads: " << opt::numThreads << "\n";
    die = true;
  }
  
  if (opt::contig_bam.length() == 0) {
    cout << "Must supply a contig bam with -b flag (usually all_bwa.bam)" << endl;
    die = true;
  }

  opt::skip_realign = opt::discovar_acount_rule ? true : opt::skip_realign;

  // if you are passing a "final" bam, skip the realignment, it's already done
  if (opt::r2c_bam.find("final") != string::npos || opt::r2c_bam.find("matched") != string::npos)
    opt::skip_realign = true;


  // check the contig bam file
  if (!SnowUtils::existTest(opt::contig_bam)) {
    cerr << "Could not find contig bam files " << opt::contig_bam << endl;
    die = true;
  }
  
  // check the discovar file
  if (!SnowUtils::existTest(opt::discovar_acount) && opt::discovar_acount != "") {
    cerr << "Could not find the supplied discovar acount file: " << opt::discovar_acount << endl;
    die = true;
  }
    
  // check that the contig bam file is readable
  BamReader reader;
  if (!reader.Open(opt::contig_bam)) {
    cerr << "Cannot open bam: " << opt::contig_bam << endl;
    die = true;
  }
  reader.Close();

  // check if the r2c bam is already aligned, if so set skip alignment
  BamReader reader_r2c;
  if (SnowUtils::existTest(opt::r2c_bam) && !reader_r2c.Open(opt::r2c_bam)) {
    cerr << "Cannon open r2c bam: " << opt::r2c_bam << endl;
    die = true;
  }
  /* size_t count = 0;
  BamAlignment a;
  string cn;
  while (reader_r2c.GetNextAlignment(a) && count < 10) {
    if (a.GetTag("CN", cn)) {
      break;
    } else {
      count++;
    }
    }*/
  //if (count < 10) {
  //  opt::skip_realign = true;
  //  cout << "  Reads in r2c bam have already been SW aligned. Skipping realignment." << endl;
  //}
  
  // something went wrong, kill
  if (die) {
    cout << "\n" << CONCAT_USAGE_MESSAGE;
    exit(1);
  }

}

// split string, from http://stackoverflow.com/questions/236129/how-to-split-a-string-in-c
vector<string> &csplit(const string &s, char delim, vector<string> &elems) {
  stringstream ss(s);
  string item;
  while (getline(ss, item, delim)) {
   elems.push_back(item);
  }
  return elems;
}

// split string, from http://stackoverflow.com/questions/236129/how-to-split-a-string-in-c
vector<string> csplit(const string &s, char delim) {
  vector<string> elems;
  csplit(s, delim, elems);
  return elems;
}
 
// mark duplicates in vector
/*void markDuplicates(BPVec &bp) {
  unsigned jj = 1;
  unsigned it = 0;
  while (it < bp.size()) {
    bp[it].isBest = true; // if we see it here, it's the top of the list (A)AAA(B)(C)C etc
    while (it+jj < bp.size())
      if (bp[it].sameBreak(bp[it+jj])) { // same break
	jj++;
	bp[it].num_dups++;
      } else {
        it = it + jj - 1; // skip over all elements noted to be dups
	break;
      }
    jj = 1;
    it++;
  }
  }*/

/*
void removeDuplicates(BPVec &in, BPVec &out) {
  for (unsigned it = 0; it < in.size(); it++)  // was -1
    if (in[it].isBest)
      out.push_back(in[it]);
      }*/

void readContigBAM(ContigMap * contigs) {

  if (opt::verbose > 0)
    cout << "...reading in contig BAM: " << opt::contig_bam << endl;

  BamReader reader;
  if (!reader.Open(opt::contig_bam)) {
    cerr << "Cannot open bam: " << opt::contig_bam << endl;
    exit(EXIT_FAILURE);
  }

  BamAlignment a;

  bool addSingles = false;

  size_t count = 0;

  bool discovar = opt::discovar_acount != "";

  unordered_map<string, string> discovar_dedupe, blacklist;
  
  
  while (reader.GetNextAlignment(a)) {

    count++;
    if (count % 5000000 == 0) {
      char buffer[100];
      sprintf(buffer, " Checking/adding contig %27s at position %2d:%-9d ", a.Name.c_str(), a.RefID+1, a.Position);
      cout << buffer;
      SnowUtils::displayRuntime(start);
      cout << endl;
      
    }

    string xp;
    bool pass = a.GetTag("XP", xp);

    // if it's a discovar read, check that it's not duped 
    // (because discovar stores both fwd/rev contigs)
    if (pass) {
      
      if (discovar) {
	AcountMap::iterator mm = amap->find(a.Name);
	if (mm == amap->end()) 
	  cerr << "Couldnt find " << a.Name << " in acount file" << endl;
	else {
	  string tmp = "t" + to_string(mm->second.tum) + "n" + to_string(mm->second.norm);
	  a.AddTag("TN", "Z", tmp);
	}
      }

      /*      string rr = a.QueryBases;
      unordered_map<string, string>::iterator bb = discovar_dedupe.find(rr);
      if (bb == discovar_dedupe.end()) {
	rcomplement(rr);
	bb = discovar_dedupe.find(rr);
      }
	
      pass = (blacklist.find(a.Name) == blacklist.end());

      if (pass) // has XP and is not blacklisted
	if (bb == discovar_dedupe.end()) { // this alignment not seen before
	  discovar_dedupe.insert(pair<string, string>(rr, a.Name));
	} else if (bb->second != a.Name) { // alignment seen before, but wrong name. Blacklist name
	  blacklist.insert(pair<string, string>(a.Name, ""));
	  pass = false;
	} 
      */

      // if it's a discovar run, check that it is in the acount file
      //if (discovar && pass) {
      //	pass = mm != amap->end();
      //}
    }

    // if the contig is one that is doubled, add
    if (pass) {
      
      ContigMap::iterator ff = contigs->find(a.Name);

      //if contig not there, check if good
      if (ff == contigs->end()) {
	vector<int> chr;
	vector<int> pos;
	vector<int> mapq;
	vector<int> nmvec;
	mapq.push_back(a.MapQuality);
	parseXPString(xp, chr, pos, mapq, nmvec);
	int maxr = *max_element(mapq.begin(), mapq.end());
	int minr = *min_element(mapq.begin(), mapq.end());
	//int nm;
	//if (!a.GetTag("NM", nm)) {
	//  nm = 0;
	//}
	//nmvec.push_back(nm);
	//int nmmax = *max_element(nmvec.begin(), nmvec.end());
	// add a new contig if it is good
	//cout << xp e<< " nm " << nm << " maxr " << maxr << " minr " << minr << " nmmax " << nmmax << " mapq.size() " << mapq.size() << endl;
	//bool add_alignment = maxr >= 30 && ( (minr >= 30 && nmmax < 100000) || mapq.size() > 2);
	bool add_alignment = minr >= opt::min_mapq && maxr >= opt::max_mapq && a.Length >= opt::min_length;
	if (add_alignment) {
	  //AlignedContig ac(a);
	  //ac.addBams(opt::tumor_bam, opt::normal_bam, opt::panel_bam, opt::r2c_bam);
	  //contigs->insert(pair<string, AlignedContig>(a.Name, ac));
	}
      } else {
	ff->second.addAlignment(a);
      }
    }
    
  }
  
  // find out the number of reads and display info
  if (opt::verbose > 0) {
    unsigned singlem = 0;
    unsigned doublem = 0;
    unsigned multim  = 0;
    for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++)
      if (it->second.getNumPrimaryAlign() == 1) {
	singlem++;
	if (!addSingles) {
	  cerr << "ERROR: Single mapped contigs processed, when none were requested for " << it->second.getContigName() << " " << it->second.getAlignments()[0].align.RefID+1 << ":" << it->second.getAlignments()[0].align.Position << endl;
	  exit(1);
	}
      } else if (it->second.getNumPrimaryAlign() == 2) {
	doublem++;
      } else {
	multim++;
      }

    // count the alignments
    unsigned num_secondary = 0;
    unsigned num_primary = 0;
    for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) {
      num_secondary += it->second.getNumSecondaryAlign();
      num_primary += it->second.getNumPrimaryAlign();
    }
  
    // display some info on the contig BAM
    if (opt::verbose > 0) {
      SnowUtils::displayRuntime(start); 
      cout << endl << "  Contigs read: " << contigs->size() << " -- Single: " <<
	singlem << " Double: " << doublem << " 3+: " << multim;
      cout << "  Aligns: -- 1o: " << num_primary << " 2o: " << num_secondary << endl;
    }


  }

  } 

// read in the read2contig bam mapping (r2c.bam)
/*
void readR2C(ContigMap *contigs) {

  //string allread = opt::directory + "/r2c_clean.bam";
  if (!SnowUtils::existTest(opt::r2c_bam)) {
    cerr << "Could not find r2c bam files " << opt::r2c_bam << endl;
    exit(EXIT_FAILURE);
  }

  BamReader r2c_reader;

  if (!r2c_reader.Open(opt::r2c_bam))
    cerr << "Cannot open bam: " << opt::r2c_bam << endl;

  // read in the read to contig alignments
  if (opt::verbose > 0)
    cout << "...reading read2contig bam " << opt::r2c_bam << endl;

  BamAlignment q;
  unsigned count = 0;
  unsigned added_read_count = 0;
  
  while(r2c_reader.GetNextAlignment(q)) {
    
    // display
    count++;
    if (count % 1000000 == 0) {
      int perc  = static_cast<int>(floor((float)added_read_count / (float)count * 100.0));
      char buffer[100];
      int disp_count = count / 1000000;
      sprintf (buffer, " Added read at %2d:%-9d, tried  %2de6, added %7d (%2d%%) ", 
	       q.RefID+1, q.Position, disp_count, added_read_count, perc);
      cout << buffer;
      SnowUtils::displayRuntime(start);
      cout << endl;
    }

    string this_cn, this_al; 
    q.GetTag("CN", this_cn);
    q.GetTag("AL", this_al);

    // parse the CN tag
    StringVec tags = csplit(this_cn, 'x');
    StringVec alis = csplit(this_al, 'x');

    // loop through each of the parsed tokens for this read (aka [contig1]x[contig2]x[contig3])
    for (unsigned rr = 0; rr < tags.size(); rr++) {

      string this_contig = tags[rr];
      string this_align  = alis[rr];

      ContigMap::iterator ff = contigs->find(this_contig);
      bool good_cont = ff != contigs->end(); // check if in map
      bool good_alis = this_align.compare("-1") != 0;

      // only add non -1 tags and ones with valid contig
      if (good_alis && good_cont) {

        int al;
	al = max(stoi(this_align), 0);
	
	string trim_seq;
	q.GetTag("TS", trim_seq);
	string tagname;
	q.GetTag("JW", tagname);
	Read2Contig rc(this_contig, tagname, al, q, trim_seq);

	ff->second.addRead2Contig(rc);
	added_read_count++;
      }
    }
  }

  if (opt::verbose > 0) {
    SnowUtils::displayRuntime(start); 
    cout << endl;
  }

}
*/

void sendBlat(ContigMap *contigs) {

  if (opt::verbose > 0)
    cout << "...running BLAT" << endl;

  // run if needs to be run
  string etest = opt::outdir + "/contigs/blat.somatic.psl";
  if (!SnowUtils::existTest(etest)) {

    string cmd_ger = "blat " + REFHG19 + " " + opt::outdir + "/contigs/contigs.germline.txt " + 
      opt::outdir + "/contigs/blat.germline.psl";
    string cmd_som = "blat " + REFHG19 + " " + opt::outdir + "/contigs/contigs.somatic.txt " + 
      opt::outdir + "/contigs/blat.somatic.psl";

    if (opt::verbose > 0)
      cout << "Running Blat as: " << cmd_som << endl;
    system(cmd_som.c_str());

    if (opt::verbose > 0)
      cout << "Running Blat as: " << cmd_ger << endl;
    system(cmd_ger.c_str());

  }

  // parse the out file
  std::ifstream file_s(opt::outdir + "/contigs/blat.somatic.psl");
  std::ifstream file_g(opt::outdir + "/contigs/blat.germline.psl");
  std::string line;

  // skip the headers (first 5 lines)
  for (unsigned i = 0; i < 6; i++) {
    getline(file_s, line);
    getline(file_g, line);
  }

  // parse the lines and add to the contigs
  while (std::getline(file_s, line)) {
    SBlat b(line);
    (*contigs)[b.query_name].addSBlat(b);
  }
  while (std::getline(file_g, line)) {
    SBlat b(line);
    (*contigs)[b.query_name].addSBlat(b);
  }

}

void sendRepeatMasker(ContigMap *contigs) {
  
  if (opt::verbose > 0)
    cout << "...handling RepeatMasker" << endl;

  // run if if needs to be run
  std::string etest = opt::outdir + "/contigs/contigs.somatic.txt.masked";
  if (!SnowUtils::existTest(etest)) {

    // make the command
    std::string cmd_som = "RepeatMasker -species human " + opt::outdir + "/contigs/contigs.somatic.txt";
    std::string cmd_ger = "RepeatMasker -species human " + opt::outdir + "/contigs/contigs.germline.txt";

    if (opt::verbose > 0)
      std::cout << "Running RepeatMasker as: " << cmd_som << std::endl;
    std::system(cmd_som.c_str());
    
    if (opt::verbose > 0)
      std::cout << "Running RepeatMasker as: " << cmd_ger << std::endl;
    std::system(cmd_ger.c_str());
  }

  string gfile = opt::outdir + "/contigs/contigs.germline.txt.out";
  string sfile = opt::outdir + "/contigs/contigs.somatic.txt.out";
  
  string line;

  // read in the germline repeats
  if (SnowUtils::existTest(gfile)) {
    
    // read the masked contigs
    string germ_mask = opt::outdir + "/contigs/contigs.germline.txt.masked";
    if (SnowUtils::existTest(germ_mask)) {
      StrStrMap cont = readFasta(germ_mask);
      for (StrStrMap::const_iterator it = cont.begin(); it != cont.end(); it++)
	if (contigs->find(it->first) != contigs->end())
	  (*contigs)[it->first].addMaskedSeq(it->second);
    }

    // read the output file
    string germ_out = opt::outdir + "/contigs/contigs.germline.txt.out";
    if (SnowUtils::existTest(germ_out)) {
      ifstream fileo(germ_out);

      // skip the headers
      for (unsigned i = 0; i < 4; i++) 
	getline(fileo, line);
      while (std::getline(fileo, line)) {
	RepeatMasker rp(line);
	(*contigs)[rp.contig].addRepeatMasker(rp);
      }
    }

  }

  // read in the somatic repeats
  if (SnowUtils::existTest(sfile)) {
    
    // read the masked contigs
    string mask = opt::outdir + "/contigs/contigs.somatic.txt.masked";
    if (SnowUtils::existTest(mask)) {
      StrStrMap cont = readFasta(mask);
      for (StrStrMap::const_iterator it = cont.begin(); it != cont.end(); it++)
	if (contigs->find(it->first) != contigs->end())
	  (*contigs)[it->first].addMaskedSeq(it->second);
    }

    // read the output file
    string som_out = opt::outdir + "/contigs/contigs.somatic.txt.out";
    if (SnowUtils::existTest(som_out)) {
      ifstream fileo(som_out);

      // skip the headers
      for (unsigned i = 0; i < 4; i++) 
	getline(fileo, line);
      while (std::getline(fileo, line)) {
	RepeatMasker rp(line);
	(*contigs)[rp.contig].addRepeatMasker(rp);
      }
    }

  }

}


// read a FASTA file into a StringMap
StrStrMap readFasta(string file) {
  
  StrStrMap sm;

  // read the file
  gzFile fp = gzopen(file.c_str(), "r");
  if(fp == 0) {
    perror("fopen");
    exit(1);
  }

  kseq_t *seq = kseq_init(fp);
  int l;     

  while ((l = kseq_read(seq)) >= 0) 
    sm.insert(pair<string, string>(seq->name.s, seq->seq.s));

  //printf("return value: %d\n", l);  
  kseq_destroy(seq); // STEP 5: destroy seq  
  gzclose(fp); // STEP 6: close the file handler  
  return sm;

}

// write the contigs that make it through to seperate somatic and germline files
void writeContigs(const ContigMap *contigs) {

  // make the folder
  std::string dir = "mkdir -p " + opt::outdir + "/contigs";
  std::system(dir.c_str());

  // setup contig out
  ofstream som_fasta_stream(opt::outdir + "/contigs/contigs.somatic.txt", ios::out);
  ofstream ger_fasta_stream(opt::outdir + "/contigs/contigs.germline.txt", ios::out);

  // Print the somatic contigs
  for (ContigMap::const_iterator i = contigs->begin(); i != contigs->end(); i++) {
    if (i->second.isSomatic())
      i->second.printContigFasta(som_fasta_stream);
    if (i->second.isGermline())
      i->second.printContigFasta(ger_fasta_stream);
  }

  // write the multi-aligned contigs to a BAM
  if (opt::verbose > 0)
    cout << "...writing the contigs_multi.bam" << endl;

  BamWriter contigs_writer;

  //get the header
  SamHeader sam;
  //SVBamReader::getSamHeader(opt::contig_bam, sam);

  // get the reference data
  RefVector ref;  
  //SVBamReader::getRefVector(opt::contig_bam, ref);

  string contigs_outbam = opt::outdir + "/contigs_multi.bam";
  if (!contigs_writer.Open(contigs_outbam, sam, ref)) {
    cerr << "Error initializing BAM for " << contigs_outbam << endl;
    return;
  }

  BamAlignmentVector cvec;
  for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) 
    if (it->second.isSomatic() || it->second.isGermline()) {
      for (AlignVec::const_iterator jt = it->second.m_align.begin(); jt != it->second.m_align.end(); jt++) {
	BamAlignment tmp = jt->align;
	tmp.Qualities = string(tmp.QueryBases.length(), 'I'); // add dummy scores
	if (tmp.RefID < 25)
	  cvec.push_back(tmp);
      }
    }

  // sort them by position
  sort(cvec.begin(), cvec.end(), Algorithms::Sort::ByPosition());
  
  // write them out
  for (vector<BamAlignment>::const_iterator it = cvec.begin(); it != cvec.end(); it++)
    contigs_writer.SaveAlignment(*it);
  contigs_writer.Close();

  //write the index
  BamReader cc;
  if (!cc.Open(contigs_outbam)) {
    cerr << "FAILED TO OPEN CONTIGS_MULTI.BAM AFTER PRODUCTION" << endl;
  }
  if (!cc.CreateIndex()) {
    cerr << "FAILED TO CREATE CONTIGS_MULTI.BAM INDEX AFTER PRODUCTION" << endl;
  }


}

// print the alignments of the reads to the contigs
void writeAsciiPlots(const ContigMap *contigs) {

  if (opt::verbose > 0) 
    cout << "...sending Ascii plots" << endl;
  
  // make the folder
  std::string dir = "mkdir -p " + opt::outdir + "/alignments";
  std::system(dir.c_str());
  
  // setup the ASCII plots
  ofstream som_align_stream(opt::outdir + "/alignments/alignments.somatic.txt", ios::out);
  ofstream ger_align_stream(opt::outdir + "/alignments/alignments.germline.txt", ios::out);
  ofstream all_align_stream(opt::outdir + "/alignments/alignments.all.txt", ios::out);

  // Print the somatic, germline, all plots
  for (ContigMap::const_iterator i = contigs->begin(); i != contigs->end(); i++) {
    //i->second.printAlignments(all_align_stream);
    if (i->second.isSomatic())
      som_align_stream << i->second.printAlignments();
    else if (i->second.isGermline())
      ger_align_stream <<  i->second.printAlignments();
    else 
      all_align_stream << i->second.printAlignments();
  }
}

// write the breakpoint files
void writeBreakFiles(BPVec &fine, BPVec &glob) {

  if (opt::verbose > 0)
    cout << "...sending breakpoints to a file\n";

  // make the folder
  string dir = "mkdir -p " + opt::outdir + "/breakpoints";
  system(dir.c_str());

  // make the header
  string sep = ",";

  string disc = "";
  if (opt::discovar_acount != "")
    disc = sep + "discovar_tumor" + sep + "discovar_normal";

  string header = BreakPoint::BreakPointHeader();

  // make the output file names
  stringstream out_som_fine; out_som_fine << opt::outdir << "/breakpoints/breakpoints.somatic.fine.txt";
  stringstream out_som;      out_som      << opt::outdir << "/breakpoints/breakpoints.somatic.txt";
  stringstream out_ger_fine; out_ger_fine << opt::outdir << "/breakpoints/breakpoints.germline.fine.txt";
  stringstream out_ger;      out_ger      << opt::outdir << "/breakpoints/breakpoints.germline.txt";
  //stringstream out_ger_comp;      out_ger_comp      << opt::outdir << "/breakpoints/breakpoints.germline.complex.txt";
  //stringstream out_som_comp;      out_som_comp      << opt::outdir << "/breakpoints/breakpoints.somatic.complex.txt";
  //stringstream out_ger_comp_fine;      out_ger_comp_fine      << opt::outdir << "/breakpoints/breakpoints.germline.complex.fine.txt";
  //stringstream out_som_comp_fine;      out_som_comp_fine      << opt::outdir << "/breakpoints/breakpoints.somatic.complex.fine.txt";
  ofstream os_som_fine (out_som_fine.str(), ios::out);
  ofstream os_som      (out_som.str(),      ios::out);
  ofstream os_ger_fine (out_ger_fine.str(), ios::out);
  ofstream os_ger      (out_ger.str(),      ios::out);
  //ofstream os_ger_comp      (out_ger_comp.str(),      ios::out);
  //ofstream os_som_comp      (out_som_comp.str(),      ios::out);
  //ofstream os_ger_comp_fine      (out_ger_comp_fine.str(),      ios::out);
  //ofstream os_som_comp_fine      (out_som_comp_fine.str(),      ios::out);

  // attach the headers
  os_som_fine << header << endl;;
  os_som << header << endl;;
  os_ger_fine << header << endl;
  os_ger << header << endl;

  //os_ger_comp << header.str();
  //os_som_comp << header.str();
  //os_ger_comp_fine << header.str();
  //os_som_comp_fine << header.str();
  
  // send fine to files
  /*
  for (BPVec::iterator it = fine.begin(); it != fine.end(); it++) {
    if (it->isSomatic) 
      it->printToFile(os_som_fine, contigs_realigned);
    if (it->isGermline)  // must have 2 split, 1 normal
      it->printToFile(os_ger_fine, contigs_realigned);
  }
  */

  // send global to files
  /*for (BPVec::iterator it = glob.begin(); it != glob.end(); it++) {
    if (it->isSomatic)
      it->printToFile(os_som, (*contigs_realigned)[it->cname].m_bamreads);
    if (it->isGermline)  // must have 2 split, 1 normal
      it->printToFile(os_ger, (*contigs_realigned)[it->cname].m_bamreads);
      }*/

  //send complex global to files
  /*for (BPVec::const_iterator it = glob.begin(); it != glob.end(); it++) {
    if (it->isGoodSomatic(opt::mapq, opt::tum, 0) && it->num_align > 2)
      it->printToFile(os_som_comp);
    if (it->isGoodGermline(opt::mapq, opt::germ, 1) && it->num_align > 2)  // must have 2 split, 1 normal
      it->printToFile(os_ger_comp);
      }
  */
}

// write the output for input to R
void writeForRPlots(ContigMap *contigs) {

  if (opt::verbose > 0) 
    cout << "...printing reads to text file for R input" << endl;

  // make the folder
  string dir = "mkdir -p " + opt::outdir + "/plots";
  system(dir.c_str());

  // setup the output
  //ofstream aostream(opt::outdir + "/plots/readsForR_all.txt", ios::out);
  ofstream sostream(opt::outdir + "/plots/readsForR_som.txt", ios::out);
  ofstream gostream(opt::outdir + "/plots/readsForR_ger.txt", ios::out);
  
  // add the header
  //aostream << "contig,rname,start,seq,sw_score" << endl;
  sostream << "contig,rname,start,seq,sw_score" << endl;
  gostream << "contig,rname,start,seq,sw_score" << endl;

  for (ContigMap::const_iterator i = contigs->begin(); i != contigs->end(); i++)
    if (i->second.isSomatic())
      sostream << i->second.printForR();
    else if (i->second.isGermline())
      gostream << i->second.printForR();
  //else
  //    aostream << i->second.printForR();
}

// adf
void writeFinalBams(const ContigMap *contigs) {

  if (opt::verbose > 0)
    cout << "...writing final contig BAM" << endl;
  if (opt::contig_bam.find("final") != string::npos){
    cout << "...final bam detected as input. Dont write over" << endl;
    return;
  }

  SamHeader sam("none");
  RefVector ref;  
  for (int i = 0; i < 25; i++) {
    RefData rf(CHR_NAME[i], CHR_LEN[i]);
    ref.push_back(rf);      
  }
  

  // write the R2C final bam
  if (!opt::discovar_acount_rule) {

    /*
    if (opt::verbose > 0)
      cout << "...writing the r2c_final.bam" << endl;

    BamWriter reads_writer;
    string reads_outbam = opt::outdir + "/r2c_final.bam";
    if (!reads_writer.Open(reads_outbam, sam, ref)) {
      cerr << "Error initializing BAM for " << reads_outbam << endl;
      return;
    }

    BamAlignmentVector rvec;
    for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) 
      if (it->second.isSomatic() || it->second.isGermline()) {
	for (BamAlignmentVector::const_iterator jt = it->second.m_bamreads.begin(); jt != it->second.m_bamreads.end(); jt++)
	  rvec.push_back(*jt);
      }
    sort(rvec.begin(), rvec.end(), Algorithms::Sort::ByPosition());

    for (vector<BamAlignment>::const_iterator it = rvec.begin(); it != rvec.end(); it++)
      reads_writer.SaveAlignment(*it);
    
    reads_writer.Close();

    //write the index
    BamReader rr;
    if (!rr.Open(reads_outbam)) {
      cerr << "FAILED TO OPEN R2C_FINAL.BAM AFTER PRODUCTION" << endl;
    }
    if (!rr.CreateIndex()) {
      cerr << "FAILED TO CREATE R2C_FINAL.BAM INDEX AFTER PRODUCTION" << endl;
    }
    */

    /*
    string cmd = "samtools sort " + opt::outdir + "/r2c_final.bam " + opt::outdir + "/r2c_sort_final";
    system(cmd.c_str());
    if (opt::verbose > 0)
      cout << cmd << endl;
    cmd = "mv " + opt::outdir + "/r2c_sort_final.bam " + opt::outdir + "/r2c_final.bam";
    system(cmd.c_str());
    if (opt::verbose > 0)
      cout << cmd << endl;
    cmd = "samtools index " + opt::outdir + "/r2c_final.bam";
    system(cmd.c_str());
    if (opt::verbose > 0)
      cout << cmd << endl;  
    */
  }

  if (opt::verbose > 0)
    cout << "...writing the contigs_final.bam" << endl;

  BamWriter contigs_writer;

  string contigs_outbam = opt::outdir + "/contigs_final.bam";
  if (!contigs_writer.Open(contigs_outbam, sam, ref)) {
    cerr << "Error initializing BAM for " << contigs_outbam << endl;
    return;
  }

  BamAlignmentVector cvec;
  for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) 
    if (it->second.isSomatic() || it->second.isGermline()) {
      for (AlignVec::const_iterator jt = it->second.m_align.begin(); jt != it->second.m_align.end(); jt++) {
	BamAlignment tmp = jt->align;
	tmp.Qualities = string(tmp.QueryBases.length(), 'I'); // add dummy scores
	if (tmp.RefID < 25)
	  cvec.push_back(tmp);
      }
    }

  // sort them by position
  sort(cvec.begin(), cvec.end(), Algorithms::Sort::ByPosition());
  
  // write them out
  for (vector<BamAlignment>::const_iterator it = cvec.begin(); it != cvec.end(); it++)
    contigs_writer.SaveAlignment(*it);
  contigs_writer.Close();

  //write the index
  BamReader cc;
  if (!cc.Open(contigs_outbam)) {
    cerr << "FAILED TO OPEN CONTIGS_FINAL.BAM AFTER PRODUCTION" << endl;
  }
  if (!cc.CreateIndex()) {
    cerr << "FAILED TO CREATE CONTIGS_FINAL.BAM INDEX AFTER PRODUCTION" << endl;
  }

  /*
  // sort with samtools and index
  string cmd = "samtools sort " + opt::outdir + "/contigs_final.bam " + opt::outdir + "/contigs_sort_final";
  system(cmd.c_str());
  if (opt::verbose > 0)
    cout << cmd << endl;
  cmd = "mv " + opt::outdir + "/contigs_sort_final.bam " + opt::outdir + "/contigs_final.bam";
  system(cmd.c_str());
  if (opt::verbose > 0)
    cout << cmd << endl;
  cmd = "samtools index " + opt::outdir + "/contigs_final.bam";
  system(cmd.c_str());
  if (opt::verbose > 0)
    cout << cmd << endl;
  */

}

bool runUpdater(ContigMap *contigs) {

  int al_counter = 0;
  int print_lim = opt::skip_realign ? 500 : 100;
  for (ContigMap::iterator i = contigs->begin(); i != contigs->end(); i++) {
    al_counter++;


    if (al_counter % print_lim == 0) {

      char buffer[120];
      int perc  = static_cast<int>(floor((float)al_counter / (float)contigs->size() * 100.0));
      if (opt::skip_realign)
	sprintf (buffer, " Reading r2c reads and setting breaks for contig %7d of %7d (%2d%% done)  ", 
		 al_counter, static_cast<int>(contigs->size()), perc);
      else
	sprintf (buffer, " Realigning reads and setting breaks for contig %7d of %7d (%2d%% done)  ", 
		 al_counter, static_cast<int>(contigs->size()), perc);
      if (opt::verbose > 0) {
	cout << buffer;
	SnowUtils::displayRuntime(start);
	cout << endl;
      }
    }

    ///    i->second.updateBreakpointData(opt::skip_realign, opt::no_r2c_matched);
    
  }

  pthread_mutex_lock(&snow_lock);  
    for (ContigMap::const_iterator i = contigs->begin(); i != contigs->end(); i++) 
      contigs_realigned->insert(pair<string, AlignedContig>(i->first, i->second));
  pthread_mutex_unlock(&snow_lock);

  delete contigs;
  return true;

}

// read in the contig
/*bool runContigReader(GenomicRegion reg) {

  BamReader reader;
  if (!reader.Open(opt::contig_bam)) {
    cerr << "Cannot open bam: " << opt::contig_bam << endl;
    exit(EXIT_FAILURE);
  }
  if (!reader.OpenIndex(opt::contig_bai)) {
    cerr << "Cannot open bam index: " << opt::contig_bai << endl;
    exit(EXIT_FAILURE);
  }
  
  // set the bam region
  //BamRegion breg(reg.chr, 1, reg.chr, reg.pos2);
  if(!reader.SetRegion(reg.chr, 1, reg.chr, reg.pos2)) 
     cerr << "Failed to set BAM position in contig bam on: " << reg.toStringOffset() << endl;

  BamAlignment a, curr_start;

  bool addSingles = false;

  unsigned count = 0;

  ContigMap tmpmap;
  while (reader.GetNextAlignment(a)) {
    if (a.IsPrimaryAlignment() || true) {
      count++;
      if (count % 50000 == 0) {
	char buffer[100];
	sprintf(buffer, " Added contig %27s at position %2d:%-9d ", a.Name.c_str(), a.RefID+1, a.Position);
	cout << buffer;
	SnowUtils::displayRuntime(start);
	cout << endl;
      }
      ContigMap::iterator ff = tmpmap.find(a.Name);
      if (ff == tmpmap.end()) {
	AlignedContig ac(a);
	ac.addBams(opt::tumor_bam, opt::normal_bam, opt::panel_bam);
	tmpmap.insert(pair<string, AlignedContig>(a.Name, ac));
      } else {
	ff->second.addAlignment(a);
      }
    }
  }

  // remove the single maps and fill the static stored contig
  pthread_mutex_lock(&snow_lock);  
  if (!addSingles) 
    for (ContigMap::const_iterator it = tmpmap.begin(); it != tmpmap.end(); it++) 
      if (it->second.getNumPrimaryAlign() > 1)
	contigs_read_in->insert(pair<string, AlignedContig>(it->first, it->second));
  pthread_mutex_unlock(&snow_lock);

  return true;

  }*/

/*void readThreadContigs() {
  
  if (opt::verbose)
    cout << "...reading in contig bam" << endl;

  // read in the BAM
  vector<BamAlignment> bav;
  
  BamReader reader;
  if (!reader.Open(opt::contig_bam)) {
    cerr << "Cannot open bam: " << opt::contig_bam << endl;
    exit(EXIT_FAILURE);
  }

  BamAlignment a;
  while (reader.GetNextAlignment(a)) 
    bav.push_back(a);

  SnowUtils::displayRuntime(start);
  if (opt::verbose)
    cout << "...sorting contigs by qname" << endl;
  sort( bav.begin(), bav.end(), Algorithms::Sort::ByName() );
  SnowUtils::displayRuntime(start);

  //for (vector<BamAligment>::iterator it = bav.begin(); it != bav.end(); it++) 
  //  if (it->Name == (it+1).Name)

  // setup the queue for reading the contig.
  wqueue<ReadContigWorkItem*>  c_queue;
  vector<ConsumerThread<ReadContigWorkItem>*> c_threadqueue;
  for (unsigned i = 0; i < opt::numThreads; i++) {
    ConsumerThread<ReadContigWorkItem>* threadr = new ConsumerThread<ReadContigWorkItem>(c_queue, opt::verbose > 0);
    threadr->start();
    c_threadqueue.push_back(threadr);
  }

  // divide and send the jobs. One thread per chromosome
  GenomicRegionVector wg = GenomicRegion::getWholeGenome();
  for (GenomicRegionVector::const_iterator it = wg.begin(); it != wg.end(); it++) {
    ReadContigWorkItem * item     = new ReadContigWorkItem(*it);
    c_queue.add(item);
  }

  // wait for the threads to finish
  for (unsigned i = 0; i < opt::numThreads; i++) 
    c_threadqueue[i]->join();
  
    }*/

// fills contigs_trim
/*void trimContigs(ContigMap *contigs, ContigMap *contigs_after) {

  // select which reads to load
  for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++)
    if (it->second.getNumPrimaryAlign() > 1 && it->second.hasLocal())
      contigs_after->insert(pair<string, AlignedContig>(it->first, it->second));
}*/

// multi-threaded realign reads to contigs
void realignThreadReads(ContigMap * contigs) {

  if (opt::verbose > 0 && !opt::skip_realign)
    cout << "...reading reads from BAM and SW realigning to " << contigs->size() << " contigs" << endl;
  else if (opt::verbose > 0)
    cout << "...reading reads from r2c BAM. NO SMITH-WATERMAN REALIGNMENT. " << contigs->size() << " contigs" << endl;

  if (contigs->size() == 0) {
    cerr << "ERROR: Contigs map sent to realignThreadReads is length 0" << endl;
    return;
  }
    
  // setup the queue
  wqueue<RealignWorkItem*> queue;
  vector<ConsumerThread<RealignWorkItem>*> threadqueue;
  for (unsigned i = 0; i < opt::numThreads; i++) {
    ConsumerThread<RealignWorkItem>* threadr = new ConsumerThread<RealignWorkItem>(queue, opt::verbose > 0);
    threadr->start();
    threadqueue.push_back(threadr);
  }
  
  // divide the map and send the jobs
  size_t bin = ceil(static_cast<double>(contigs->size()) / opt::numThreads);
  size_t cc = 0;
  ContigMap::const_iterator cstart = contigs->begin();
  ContigMap::const_iterator cend = contigs->begin();
  bool new_start = false;
  for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) {

    //debug
    if (it->second.getNumPrimaryAlign() < 2) {
      cerr << "NUM PRIMARY ALIGNS IS " << it->second.getNumPrimaryAlign() << endl;
      //exit(EXIT_FAILURE);
    }
      

    // update whether we store this iterator as start pos
    if (new_start) {
      cstart = it;
      new_start = false;
    }

    ++cc;
    if ( (cc % bin) == 0 || cc == contigs->size()) {
      ContigMap * cont_out = new ContigMap();
      ContigMap::const_iterator nx = std::next(it, 1);
      cont_out->insert<ContigMap::const_iterator>(cstart, nx);
      new_start = true;
      RealignWorkItem * item     = new RealignWorkItem(cont_out);
      queue.add(item);
    }
  }

  // wait for the threads to finish
  for (unsigned i = 0; i < opt::numThreads; i++) 
    threadqueue[i]->join();

}

/*void trimContigsUsingReadSupport(ContigMap * contigs_in, ContigMap *contigs_out) {

  for (ContigMap::iterator i = contigs_in->begin(); i != contigs_in->end(); i++)
    if (i->second.getNumReads() >= 3)
      contigs_out->insert(pair<string, AlignedContig>(i->first, i->second));
  cout << "   Num contigs passing mapq, num-align and re-align: "  << contigs_out->size() << endl;


  }*/

// parse the Discovar acount file to get the number of 
// tumor / normal reads supporting each contig
void parseDiscovarAcount() {

  // open the stream
  ifstream readFile(opt::discovar_acount);
  if (!readFile.good()) {
    cerr << "Can't open the Discovar acount file: " << opt::discovar_acount << endl;
    return; // exit if file not found
  }

  if (opt::verbose > 0)
    cout << "...parsing Discovar acount file" << endl;

  // loop through and parse
  string line;
  string contig, tumor, normal;
  size_t count = 0;
  while(getline(readFile, line)) {
    count++;
    stringstream iss(line);
    getline(iss, contig, ' ');
    getline(iss, tumor, ' ');
    getline(iss, normal, ' ');
    int tc = stoi(tumor);
    int nc = stoi(normal);
    //    if ( (tc >= opt::tum && nc == 0) || (tc >= opt::tum * 4 && (tc/nc) > opt::tum*4))
    amap->insert(pair<string, ATuple>(contig, ATuple(tc, nc)));
  }

  if (opt::verbose > 0) {
    cout << "...Found a total of " << amap->size() << " Discovar contigs with acount entries" << endl;
    SnowUtils::displayRuntime(start);
    cout << endl;
  }

}

// read in and handle the discordant read thing
void readDiscordantBam() {

  if (opt::verbose > 0)
    cout << "...reading in the discordant bam file" << endl;

  BamReader reader;
  if (!reader.Open(opt::discordant_bam)) {
    cerr << "Cannot open discordant bam: " << opt::discordant_bam << endl;
    return;
  }

  BamAlignment a;
  size_t count = 0;

  // loop through and gather
  while (reader.GetNextAlignment(a)) {
    if (a.MapQuality > 0) {
      string dc;
      
      if (!a.GetTag("DC", dc))
	cerr << "Can't get DC tag. Is this a discorand read bam file from snowman?" << endl;
      
      string jw;
      a.GetTag("JW", jw);
      
      count++;
      if (count % 5000000 == 0) {
	char buffer[150];
	sprintf(buffer, " Reading discordant cluster %35s at position %2d:%-9d ", dc.c_str(), a.RefID+1, a.Position);
	cout << buffer;
	SnowUtils::displayRuntime(start);
	cout << endl;
	return;
      }
      
      DMap::iterator ff = dmap->find(dc);
      
      if (ff != dmap->end()) {
	if (jw.at(0) == 't') {
	  ff->second.tcount++;
	} else {
	  ff->second.ncount++;
	}
	stringstream nam;
	nam << jw.at(0) << a.Name;
	ff->second.addRead(nam.str()); 
	ff->second.mapq.push_back(a.MapQuality);      
      } else {
	//DiscordantCluster dl(dc);
	DiscordantCluster dl;
	
	//debug
	if (abs(dl.reg1.width()) < 3000 && abs(dl.reg2.width()) < 3000) {
	  if (jw.at(0) == 't')
	    dl.tcount++;
	  else
	    dl.ncount++;
	  dmap->insert(pair<string, DiscordantCluster>(dc, dl));
	}
      }
    } //end if mapq > 0
  }//end while
    
    // we double-counted the read pairs since we counted each read, so adjust the counts
    for (DMap::iterator it = dmap->begin(); it != dmap->end(); it++) {
      it->second.tcount = it->second.tcount / 2;
      it->second.ncount = it->second.ncount / 2;
    }
    
    //debug
    //vector<DiscordantCluster> tmpvec; 
    //for (DMap::const_iterator i = dmap->begin(); i != dmap->end(); i++) {
    //  tmpvec.push_back(i->second);
    // }
  //sort(tmpvec.begin(), tmpvec.end());

  /*
  if (opt::verbose > 0)
    cout << "...filling the genomic tree vec"  << endl;

  StringIntervalVectorMap tmpdisc1, tmpdisc2;

  for (DMap::const_iterator it = dmap->begin(); it != dmap->end(); it++) {
    
    // the first one
    StringIntervalVectorMap::iterator ff = tmpdisc1.find(it->second.reg1.chr);
    StringInterval tmpi(it->second.reg1.pos1, it->second.reg1.pos2, it->second.cluster);
    if (ff == tmpdisc1.end()) 
      tmpdisc1.insert(pair<int, StringIntervalVector>(it->second.reg1.chr, StringIntervalVector(1, tmpi)));
    else 
      ff->second.push_back(tmpi);
    
    // the second one
    StringIntervalVectorMap::iterator ff2 = tmpdisc2.find(it->second.reg2.chr);
    StringInterval tmpi2(it->second.reg2.pos1, it->second.reg2.pos2, it->second.cluster);
    if (ff2 == tmpdisc2.end()) 
      tmpdisc2.insert(pair<int, StringIntervalVector>(it->second.reg2.chr, StringIntervalVector(1, tmpi2)));
    else 
      ff2->second.push_back(tmpi2);
  }
  
  if (opt::verbose > 0)
    cout << "...making the Genomic interval tree"  << endl;

  discmap1 = new SStringTreeMap;
  discmap2 = new SStringTreeMap;

  for (StringIntervalVectorMap::const_iterator it = tmpdisc1.begin(); it != tmpdisc1.end(); it++) {
    StringIntervalVectorMap::iterator ff = tmpdisc1.find(it->first);
    if (ff == tmpdisc1.end()) {
      SStringTree * tmptree = new SStringTree(it->second);
      discmap1->insert(pair<int, SStringTree*>(it->first, tmptree));
    }
  }

  if (opt::verbose > 0) {
    SnowUtils::displayRuntime(start);
    cout << endl;
  }

*/

}

// write the contig fasta file
void writeContigFasta(ContigMap * contigs) {

  if (opt::verbose > 0)
    cout << "...writing multiple mapped contig fasta file" << endl;

  ofstream ostream;
  string ofile;
  ofile = opt::outdir + "/multiple_map.fa";
  ostream.open(ofile);

  for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) {
    ostream << ">" << it->second.getContigName() << "\n";
    ostream << it->second.getSequence() << "\n";
  }
  
  ostream.close();

}

// write a BAM file containing the original reads, annotated with
// SW (smith-waterman score), CN (contig), AL (alignment position)
// for all of the contigs with double/triple mappings.
/*void writeR2CmatchedBAM(ContigMap * contigs) {

  if (opt::verbose > 0)
    cout << "...writing the r2c_matched bam file" << endl;
  if (opt::r2c_bam.find("final") != string::npos || opt::r2c_bam.find("matched") != string::npos){
    cout << "...r2c_final or r2c_matched bam detected as input. Dont write over." << endl;
    return;
  }


  string r2c_matched = opt::outdir + "/r2c_matched_tmp.bam";
  BamWriter writer;


  //get the header
  SamHeader sam;
  SVBamReader::getSamHeader(opt::r2c_bam, sam);

  // get the reference data
  RefVector ref;  
  SVBamReader::getRefVector(opt::r2c_bam, ref);

  if (!writer.Open(r2c_matched, sam, ref))  
    cerr << "Error initializing the BAM for: " << r2c_matched << endl;
  for (ContigMap::const_iterator it = contigs->begin(); it != contigs->end(); it++) {
    for (vector<BamAlignment>::const_iterator jt = it->second.m_bamreads.begin(); jt != it->second.m_bamreads.end(); jt++) {
      if (jt->RefID < 25 && jt->MateRefID < 25)
	writer.SaveAlignment(*jt);
    }
  }
  writer.Close();
  string cmd = "cd " + opt::outdir + "; samtools sort -m 8192M r2c_matched_tmp.bam r2c_matched; samtools index r2c_matched.bam; rm r2c_matched_tmp.bam";
  if (opt::verbose > 0)
    cout << cmd << endl;
  system(cmd.c_str());
}
*/

// calls the isSomatic function and sets the somatic/germkline flags for contigs and breakpoints
void setBreakSomaticGermline(BPVec &bpvec) {
  /*  
  cout << "bpvec size setBreakSomaticGermline: " << bpvec.size() << endl;

  if (opt::discovar_acount_rule) {
    if (opt::verbose > 0)
      cout << "...using acount file to set breakpoint status" << endl;
    for (BPVec::iterator it = bpvec.begin(); it != bpvec.end(); it++) {

      assert(it->mapq1 <= 60 && it->mapq2 <= 60);

      AcountMap::iterator ff = amap->find(it->cname);
      double ratio = ff->second.tum;
      if (ff->second.norm > 0)
        ratio = (ff->second.tum / ff->second.norm);
      if ( (ff->second.tum >= opt::tum && ff->second.norm == 0) || ratio > 2 || true) {
	(*contigs_realigned)[it->cname].setSomatic(true);
	it->isSomatic = true;
      } else if ( (ff->second.tum + ff->second.norm) >= opt::germ && ff->second.norm >= 1) {
	(*contigs_realigned)[it->cname].setGermline(true);
	it->isGermline = true;
      }
    } 
  } else {
  */
    /*
    SVBamReader nreader(opt::normal_bam);
    if (opt::normal_bam != "")
      nreader.findBamIndex();

    for (BPVec::iterator it = bpvec.begin(); it != bpvec.end(); it++) {

      if (it->isGoodSomatic(opt::mapq, opt::tum, 0)) {
	
	// it says it's somatic, but double check with normal bam
	bool check_normal = it->span > 1000 || it->span < 0;
	check_normal = check_normal && opt::normal_bam != "";
	if (check_normal) {
	  GenomicRegion gr1(it->refID1, it->pos1, it->pos1);
	  GenomicRegion gr2(it->refID2, it->pos2, it->pos2);
	  gr1.pad(600);
	  gr2.pad(600);
	  nreader.setBamRegion(gr1);
	  it->dc.ncount += nreader.discordantCount(gr1, gr2, it->span);
	  if (it->dc.ncount > 0)
	    cout << " Rejecting somatic break at regions " << gr1 << " " << gr2 << " with count " << it->dc.ncount << endl;
	}
	
	if (!check_normal || it->dc.ncount == 0) { // if we didnt check, or we did and it's fine
	  ContigMap::iterator ff = contigs_realigned->find(it->cname);
	  if (ff != contigs_realigned->end()) 
	    ff->second.setSomatic(true);
	  it->isSomatic = true;
	}
      } else if (it->isGoodGermline(opt::mapq, opt::germ))  { // must have 2 split, 1 normal
	ContigMap::iterator ff = contigs_realigned->find(it->cname);
	if (ff != contigs_realigned->end())
	  ff->second.setGermline(true);
	it->isGermline = true;
      }
    }
    */
  /* }
    
    
  // debug double-check
  size_t scount = 0;
  size_t gcount = 0;
  for (BPVec::const_iterator it = bpvec.begin(); it != bpvec.end(); it++) {
    if (it->isSomatic) 
      scount++;
    else if (it->isGermline)
      gcount++;
  }
  cout << "Breakpoint somatic count: " << scount << " Germline count: " << gcount << endl;
  
  // debug double-check
  scount = 0;
  gcount = 0;
  for (ContigMap::const_iterator it = contigs_realigned->begin(); it != contigs_realigned->end(); it++) {
    if (it->second.isSomatic()) 
      scount++;
    else if (it->second.isGermline())
      gcount++;
  }
  cout << "Contigs somatic count: " << scount << " Germline count: " << gcount << endl;
  */
}

//
void combineContigsWithDiscordantClusters() {
  /*
  if (opt::verbose > 0)
    cout << "...combining discordant clusters with " << contigs_realigned->size() << " contigs" << endl;

  DMap smalldmap;
  for (DMap::const_iterator kt = dmap->begin(); kt != dmap->end(); kt++) {
    bool som = (kt->second.tcount >= 3 && kt->second.ncount == 0);
    //bool ger = (kt->second.ncount + kt->second.tcount) >= 12;
    if (som) 
      smalldmap.insert(pair<string, DiscordantCluster>(kt->first, kt->second));
  }

  int padr = 400; 
  size_t count = 0;
  for (ContigMap::iterator it = contigs_realigned->begin(); it != contigs_realigned->end(); it++) {
    count++;

    if (count % 3000 == 0) { 
      char buffer[100];
      int perc = static_cast<int>(floor( (float)count / (float)contigs_realigned->size() * 100.0));
      sprintf(buffer, " Combining %5d discordant clusters with contig %27s (%2d%%)", static_cast<int>(smalldmap.size()), it->second.getContigName().c_str(), perc);
      cout << buffer;
      SnowUtils::displayRuntime(start);
      cout << endl;
    }

    // check the global break
    GenomicRegion bp1(it->second.m_farbreak.refID1, it->second.m_farbreak.pos1, it->second.m_farbreak.pos1);
    bp1.pad(padr);
    GenomicRegion bp2(it->second.m_farbreak.refID2, it->second.m_farbreak.pos2, it->second.m_farbreak.pos2);
    bp2.pad(padr);
 
    for (DMap::iterator kt = smalldmap.begin(); kt != smalldmap.end(); kt++) {
      bool bp1reg1 = bp1.getOverlap(kt->second.reg1) != 0;
      bool bp2reg2 = bp2.getOverlap(kt->second.reg2) != 0;
      
      //debug
      bool bp1reg2 = bp1.getOverlap(kt->second.reg2) != 0;
      bool bp2reg1 = bp2.getOverlap(kt->second.reg1) != 0;

      bool pass = bp1reg1 && bp2reg2;

      //debug
      pass = pass || (bp2reg1 && bp1reg2);

      if (pass) {
	it->second.addDiscordantCluster(kt->second); // add disc cluster to contig

	// check that we haven't already added a cluster
	kt->second.contig = it->second.getContigName(); // add contig to disc cluster
	if (it->second.m_farbreak.dc.reg1.pos1 == 0) {
	  it->second.m_farbreak.dc = kt->second; // add cluster to global breakpoints
	} else if (it->second.m_farbreak.dc.ncount < kt->second.ncount) { // add one with normal support
	  it->second.m_farbreak.dc = kt->second;
	} else if (it->second.m_farbreak.dc.tcount < kt->second.tcount) { // add one with more tumor support
	  it->second.m_farbreak.dc = kt->second;
	}
	//break;
      }
    }
  }

  */
    /*    if (it->second.m_breaks.size() > 1)
      for (BPVec::iterator jt = it->second.m_breaks.begin(); jt != it->second.m_breaks.end(); jt++) {
	
	GenomicRegion bp1(jt->refID1, jt->pos1, jt->pos1);
	bp1.pad(padr);
	GenomicRegion bp2(jt->refID2, jt->pos2, jt->pos2);
	bp2.pad(padr);
	
	string clust = "";
	for (DMap::iterator kt = smalldmap.begin(); kt != smalldmap.end(); kt++) {
	  bool bp1reg1 = bp1.getOverlap(kt->second.reg1) != 0;
	  bool bp2reg2 = bp2.getOverlap(kt->second.reg2) != 0;
	  //bool bp1reg2 = bp1.getOverlap(kt->second.reg2) != 0;
	  //bool bp2reg1 = bp2.getOverlap(kt->second.reg1) != 0;
	  bool pass = bp1reg1 && bp2reg2;
	  if (pass) {
	    it->second.addDiscordantCluster(kt->second); // add disc cluster to contig
	    kt->second.contig = it->second.getContigName(); // add contig to disc cluster
	    jt->dc = kt->second; // add disc cluster to breakpoint
	    break;
	  }
	}
      } // end m_breaks
    */

	//int32_t abspos1 = GenomicRegion::convertPos(jt->refID1, jt->pos1);
	//int32_t abspos2 = GenomicRegion::convertPos(jt->refID2, jt->pos2);
      //cout << "refid " << jt->refID1 << " " << jt->pos1 << endl;
      //GenomicIntervalVector giv1, giv2;
      //discordant_tree[jt->refID1]->findOverlapping(jt->pos1-padr, jt->pos1+padr, giv1);
      //discordant_tree[jt->refID2]->findOverlapping(jt->pos2-padr, jt->pos2+padr, giv2);
      //cout << "GIV1: " << giv1.size() << " GIV2: " << giv2.size() << endl;
      //if (giv1.size() == 1 && giv2.size() == 1) {
      //	if (giv1.back().value.pos1 == giv2.back().value.pos1 && giv1.back().value.pos2 == giv2.back().value.pos2)
      //	  cout << "Found overlap for breakpoint " << *jt << " at GRs " << giv1.back().value << " " << giv2.back().value << endl;
      //}
	

  // fill in the contig info for the big one
  //  for (DMap::const_iterator it = smalldmap.begin(); it != smalldmap.end(); it++)
  //  (*dmap)[it->first].contig = it->second.contig;

}

void writeDiscordantBreakpoints() {

  if (opt::verbose > 0) 
    cout << "...writing discordant breakpoint file" << endl;
  
  ofstream som_disc(opt::outdir + "/breakpoints/discordant.somatic.txt", ios::out);
  ofstream ger_disc(opt::outdir + "/breakpoints/discordant.germline.txt", ios::out);

  // transfer to a vector and sort
  vector<DiscordantCluster> tmpvec; 
  for (DMap::const_iterator i = dmap->begin(); i != dmap->end(); i++) {
    tmpvec.push_back(i->second);
  }

  // sort it
  //sort(tmpvec.begin(), tmpvec.end());

  // Print the somatic, germline, all plots
  for (vector<DiscordantCluster>::const_iterator i = tmpvec.begin(); i != tmpvec.end(); i++) {
    if (i->ncount == 0)
      som_disc << i->toFileString() << endl;
    else 
      ger_disc << i->toFileString() << endl;;
  }
}

// transfer discordant pairs not mapped to a split break 
void addDiscordantPairsBreakpoints(BPVec &bp) {

  if (opt::verbose > 0)
    cout << "...transfering discordant clusters to breakpoints structure" << endl;

  for (DMap::const_iterator it = dmap->begin(); it != dmap->end(); it++) {
    if (it->second.contig == "") { // this discordant cluster isn't already associated with a break
      BreakPoint tmpbp(it->second);
      bp.push_back(tmpbp);
    }
  }
}


