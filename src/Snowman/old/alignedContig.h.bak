#ifndef ALIGNED_CONTIG_H
#define ALIGNED_CONTIG_H

#include "Util.h" //TODO
#include "GenomicRegion.h"
#include <algorithm>
#include "BreakPoint.h"
#include "AuxUtils.h"
#include "api/BamReader.h"
#include "api/BamWriter.h"
#include "api/algorithms/Sort.h"
#include "SnowUtils.h"

#include "reads.h"

using namespace std;

typedef vector<BamTools::CigarOp> CigarOpVec;
typedef unordered_map<string, size_t> CigarMap;

class AlignedContig;
typedef unordered_map<string, AlignedContig> ContigMap;
typedef vector<AlignedContig> AlignedContigVec;


/*! This class contains a single alignment fragment from a contig to
 * the reference. For a multi-part mapping of a contig to the reference,
 * an object of this class represents just a single fragment from that alignment.
 */
struct AlignmentFragment {

  int break1 = -1; /**< 0-based breakpoint 1 on contig */
  int break2 = -1; /**< 0-based breakpoint 2 on contig */
  int gbreak1 = -1; /**< 0-based breakpoint 1 on reference chr */
  int gbreak2 = -1; /**< 0-based breakpoint 1 on reference chr */

  BamTools::BamAlignment align; /**< BWA alignment to reference */

  FragmentBreak frag_multi; /**< fragment break for left-right ends */

  BreakVec indel_breaks; /**< indel variants on this alignment */
  
  size_t start; /**< the start position of this alignment on the reference. */

  bool local = false; /**< boolean to note whether this fragment aligns to same location is was assembled from */

  size_t idx = 0; /**< index of the cigar where the last indel was taken from */

  /*! Construct an AlignmentFragment from a BWA alignment
   * @param const reference to a BamAlignment
   * @param const reference to a GenomicRegion window where this contig was assembled from
   */
  AlignmentFragment(const BamTools::BamAlignment &talign, const GenomicRegion &window);
  
  //! sort AlignmentFragment objects by start position
  bool operator < (const AlignmentFragment& str) const { return (start < str.start); }

  //! print the AlignmentFragment
  friend ostream& operator<<(ostream &out, const AlignmentFragment& c); 

  /*! @function
   * @abstract Parse an alignment frag for a breakpoint
   * @param reference to a BreakPoint to be created
   * @return boolean informing whether there was a remaining indel break
   */
  bool parseIndelBreak(BreakPoint &bp);

  /*! @function check if breakpoints match any cigar strings direct from the reads
   * This is important in case the assembly missed a read (esp normal) that indicates
   * that there is an indel. Basically this function says that if assembly calls a breakpoint
   * and it agrees with a read alignment breakpoint, combine the info.
   * @param const CigarMap reference containing hash with key=chr_breakpos_indeltype, val=tumor count
   * @param const CigarMap reference containing hash with key=chr_breakpos_indeltype, val=normal count
   */
  void indelCigarMatches(const CigarMap &nmap, const CigarMap &tmap);  


};

// define a way to order the contigs by start
/*struct AlignmentOrdering {
  inline bool operator() (const AlignmentFragment& struct1, const AlignmentFragment& struct2) {
    return (struct1.start < struct2.start);
  }
  };*/

//! vector of AlignmentFragment objects
typedef vector<AlignmentFragment> AlignmentFragmentVector;

/*! Contains the mapping of an aligned contig to the reference genome,
 * along with pointer to all of the reads aligned to this contig, and a 
 * store of all of the breakpoints associated with this contig
 */
class AlignedContig {

 public:  

  /*! Constructor which parses an alignment record from BWA (a potentially multi-line SAM record)
   * @param const reference to a string representing a SAM alignment (contains newlines if multi-part alignment)
   * @param const pointer to a BamReader, which is used to convert chr ids to strings (e.g. X, Y)
   * @param const reference to a GenomicRegion window specifying where in the reference this contig was assembled from.
   */
  AlignedContig(const std::string &sam, const BamTools::BamReader * reader, const GenomicRegion &twindow);

  bool hasvariant = false; /**< flag to specify whether this alignment has some potential variant (e.g. not full match to ref) */

  vector<BreakPoint> break_vec; /**< store all of the multi-map BreakPoints for this contigs */
  vector<BreakPoint> global_break  /**< store the single spanning BreakPoing for this contig */

  ReadVec m_bamreads; /**< store smart pointers to all of the reads that align to this contig */

  AlignmentFragmentVector m_align; /**< store all of the individual alignment fragments */

  string samrecord; /**< the original SAM record */

  GenomicRegion window; /**< reference window from where this contig was assembled */

  bool skip = false; /**< flag to specify that we should minimally process and simply dump to contigs_all.sam */

  /*! @function Determine if this contig has identical breaks and is better than another.
   * @param const reference to another AlignedContig
   * @return bool bool returning true iff this contig has identical info has better MAPQ, or equal MAPQ but longer */
  bool isBetter(const AlignedContig &ac) const;
  
  int maxSplit() const;

  /*! @function
    @abstract  Get whether the query is on the reverse strand
    @param  b  pointer to an alignment
    @return    boolean true if query is on the reverse strand
  */
  void addAlignment(const BamTools::BamAlignment align);

  void addDiscordantCluster(DiscordantCluster dc) { m_dc.push_back(dc); } 

  int numDiscordantClusters() const { return m_dc.size(); }

  /*! @function loop through the vector of DiscordantCluster objects
   * associated with this contig and print
   */
  string printDiscordantClusters() const;

  // return the name of the contigs
  string getContigName() const { assert(m_align.size()); return m_align[0].align.Name; }
 
  int getMaxMapq() const { 
    int m = -1;
    for (auto& i : m_align)
      if (i.align.MapQuality > m)
	m = i.align.MapQuality;
    return m;
  }

  int getMinMapq() const { 
    int m = 1000;
    for (auto& i : m_align)
      if (i.align.MapQuality < m)
	m = i.align.MapQuality;
    return m;
  }

  /*! @function loop through all of the breakpoints and
   * calculate the split read support for each. Requires 
   * alignedReads to have been run first (will error if not run).
   */
  void splitCoverage();

  /*! @function if this is a Discovar contig, extract
   * the tumor and normal read support
   * @param const string reference to contig name to be parsed
   * @param reference to int to fill for normal support
   * @param reference to int to fill for tumor support
   * @return boolean reporting if this is a discovar name
   */
  bool parseDiscovarName(const std::string &name, int &tumor, int&normal);

  string printAlignments() const;

  void printContigFasta(ofstream &ostream) const;

  //bool intersect(const AlignedContig *al) const; 

  // parses the contig file name to determine where the anchor window was
  //void setWindow(const string s);

  // 
  //Window getWindow() const { return m_window; }

  // find the breakpoint pairs by looping through ALL the alignments
  void getBreakPairs();
   
  // add masked seq
  //void addMaskedSeq(string seq) { m_masked_seq  = seq; }

  // add repeat masker
  //void addRepeatMasker(RepeatMasker rp) { 
  //  m_rep_vec.push_back(rp); 
  //  sort(m_rep_vec.begin(), m_rep_vec.end());
  // }

  // add SBlat alignment
  void addSBlat(SBlat b) { 
    m_blat_vec.push_back(b); 
    sort(m_blat_vec.begin(), m_blat_vec.end());
  }
  
  // run all the algorithms for updating the breakpoints, in case other parts changed
  /*void updateBreakpointData(bool skip_realign, bool no_r2c_matched) {

    // realign the reads to the contigs

    if (!skip_realign) 
      realignReads();
    else
      readR2Creads();

    // sort the reads for better visualization
    if (!no_r2c_matched)
      sortReads(); 

    // get the split coverage
    splitCoverage();

    // get the break pairs
    getBreakPairs();

    //debug
    if (m_breaks.size() == 0)
      cerr << "m_align size: "<< m_align.size() << endl;

    // if we don't need to write the output, clear most of the read data
    if (no_r2c_matched) {
      for (BamAlignmentVector::iterator it = m_bamreads.begin(); it != m_bamreads.end(); it++) {
	it->QueryBases = "";
	it->Qualities = "";
	it->RemoveTag("JW");
	it->RemoveTag("TS");
      }
    }

  }
  */
  void readR2Creads();

  BreakPoint getGlobalBreak() const { assert(m_farbreak.gr1.mapq <= 60 && m_farbreak.gr2.mapq <= 60); return m_farbreak; }

  // doing a more stringent alignment of reads to the contig
  // this is to remove normals that ruin somatic calls
  void realignReads();

  string getName() const { return m_align[0].align.Name; }

  void alignReadsToContigs(ReadVec &bav, bool indel);

  AlignVec getAlignments() const { return m_align; }

  void setSomatic(const bool somatic) { m_somatic = somatic; }

  void setGermline(const bool germline) { m_germline = germline; }

  void addBams(string tum, string norm, string pan, string r2c) { 
    tbam = tum;
    nbam = norm;
    pbam = pan;
    rbam = r2c;
  }

  //vector<BamAlignment> getBamReads() const { return m_bamreads; }

  void indelCigarMatches(CigarMap &nmap, CigarMap &tmap);

  void settleContigs();

  string getSequence() const { return m_seq; }

  bool hasSubSequence(const string& subseq) const { 
    return (m_seq.find(subseq) != string::npos);
  }
  

  friend ostream& operator<<(ostream &out, const AlignedContig &ac);
 private:

  bool tried_aligned_reads = false; // flag to specify whether we tried to align reads.


  AlignVec m_align_second;

  bool m_somatic = false;
  bool m_germline = false;
  string m_seq = "";
  string m_masked_seq = "";
  RepeatMaskerVec m_rep_vec;
  SBlatVec m_blat_vec;
  int mapq_threshold = 60;
  // store the raw alignments. Move into AlignVec if keeping the contig

  // the bam files that
  string tbam, nbam, pbam, rbam;
  //SVBamReader treader, nreader, preader;

  vector<DiscordantCluster> m_dc;

};

struct PlottedRead {

  int pos;
  string seq;
  string info;

  bool operator<(const PlottedRead& pr) const {
    return (pos < pr.pos);
  }

};

typedef vector<PlottedRead> PlottedReadVector;

struct PlottedReadLine {

  vector<PlottedRead*> read_vec;
  int available = 0;
  int contig_len = 0;

  void addRead(PlottedRead *r) {
    read_vec.push_back(r);
    available = r->pos + r->seq.length() + 5;
  }

  bool readFits(PlottedRead &r) {
    return (r.pos >= available);
  }

  friend ostream& operator<<(ostream& out, const PlottedReadLine &r) {
    int last_loc = 0;
    for (auto& i : r.read_vec) {
      assert(i->pos - last_loc >= 0);
      out << string(i->pos - last_loc, ' ') << i->seq;
      last_loc = i->pos + i->seq.length();
    }
    int name_buff = r.contig_len - last_loc;
    assert(name_buff < 10000);
    out << string(max(name_buff, 5), ' ');
    for (auto& i : r.read_vec) { // add the data
      out << i->info << ",";
    }
    return out;
  }

};

typedef vector<PlottedReadLine> PlottedReadLineVector;



#endif


