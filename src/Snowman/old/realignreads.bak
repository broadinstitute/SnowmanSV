   // print the masked contig base-pairs
   if (m_masked_seq.length() > 0)
     ostream << m_masked_seq << "    RepeatMasked contig" << endl;
   for (RepeatMaskerVec::const_iterator it = m_rep_vec.begin(); it != m_rep_vec.end(); it++) {
     int len = max(it->query_end - it->query_begin + 1, 0);
     int pre = max(it->query_begin - 1, 0);
     int post= min((int)m_seq.length() - len - pre, 1000);
     ostream << string(pre, '.') << string(len, '*') << string(post, '.') << 
       "    Repeat Element: " << it->repeat_name << " Repeat Class: " << it->repeat_class << " Percent Divergence: " << it->perc_div << " SW Score: " << it->sw << endl;
   }


// doing a more stringent alignment of reads to the contig
// this is to remove normals that ruin somatic calls
/*
void AlignedContig::realignReads() { 

   vector<BamAlignment> rr;
   // declare the readers
   int isize = 1000;
   int mapq = 0;
   int qualthresh = 4;
   int minOverlap = 35;
   bool skip_supp = false;
   bool skip_r2 = false;
   int min_clip = 8;
   int verbose = 0;

   SVBamReader treader = SVBamReader(tbam,  "tb", isize, mapq, qualthresh, minOverlap, skip_supp, skip_r2, min_clip, verbose);
   SVBamReader nreader = SVBamReader(nbam,  "nb", isize, mapq, qualthresh, minOverlap, skip_supp, skip_r2, min_clip, verbose);
   SVBamReader preader = SVBamReader(pbam,  "pb", isize, mapq, qualthresh, minOverlap, skip_supp, skip_r2, min_clip, verbose);
   SVBamReader rreader = SVBamReader(rbam,  "pb", 1, 0, qualthresh, minOverlap, skip_supp, skip_r2, min_clip, verbose);
   treader.clipOnly = true;
   nreader.clipOnly = true;
   preader.clipOnly = true;
   rreader.clipOnly = true;

   // read in the reads
   bool tgood = treader.getBamFilename().length() > 1; // && false;
   bool ngood = nreader.getBamFilename().length() > 1; // && false;
   bool pgood = preader.getBamFilename().length() > 1; // && false;
   bool rgood = rreader.getBamFilename().length() > 1;;

   size_t tvecsize = 0;

   // set the limit on number of reads to read in
   treader.setReadLimit(5000);
   nreader.setReadLimit(5000);
   preader.setReadLimit(5000);
   rreader.setReadLimit(5000);

   if (tgood) 
     if (!treader.findBamIndex())
       cerr << "Failed to open BAM index in Tumor" << endl;
   if (ngood) 
     if (!nreader.findBamIndex())
       cerr << "Failed to open BAM index in Normal" << endl;
   if (pgood) 
     if (!preader.findBamIndex())
       cerr << "Failed to open BAM index in Panel" << endl;
   if (rgood) 
     if (!rreader.findBamIndex())
       cerr << "Failed to open BAM index in R2C BAM" << endl;

   for (AlignVec::const_iterator it = m_align.begin(); it != m_align.end(); it++) {

     BamAlignmentVector this_vec;
     
     GenomicRegion rg(it->align.RefID, it->align.Position, it->align.Position + it->align.Length);

     // set the BAM region
     if (tgood) {
       if (!treader.setBamRegion(rg))
	 cerr << "Failed to set BAM position in Tumor" << endl;
       if (!treader.bamToBAVec(this_vec)) {
	 //cerr << "Failed to get BAM reads for tumor" << endl;
       }
     }

     // set the BAM region
     if (ngood) {
       if (!nreader.setBamRegion(rg))
	 cerr << "Failed to set BAM position in Normal" << endl;
       if (!nreader.bamToBAVec(this_vec)) {
	 //cerr << "Failed to get BAM reads for Normal" << endl;
       }
     }

     // set the BAM region
     if (pgood) {
       if (!preader.setBamRegion(rg))
	 cerr << "Failed to set BAM position in Panel" << endl;
       if (!preader.bamToBAVec(this_vec)) {
	 //cerr << "Failed to get BAM reads for Panel" << endl;
       }
     }

     // set the BAM region
     if (rgood) {
       if (!rreader.setBamRegion(rg))
	 cerr << "Failed to set BAM position in R2C BAM" << endl;
       if (!rreader.bamToBAVec(this_vec)) {
	 cerr << "Failed to get BAM reads for R2C BAM" << endl;
       }
     }
     
     tvecsize += this_vec.size();

     // MATCHING BY FIND
     int buff = 12;
     int pad = 10;

    for (BamAlignmentVector::iterator j = this_vec.begin(); j != this_vec.end(); j++) {
      
      string QB;
      
      if (!j->GetTag("TS", QB))
	QB = j->QueryBases;
      int seqlen = QB.length();
      size_t posa = m_seq.find(QB.substr(pad, buff)); // try first part of read
      size_t posb = m_seq.find(QB.substr(max(seqlen-buff-pad,0),buff)); // try second part of read
      bool hit1 = posa != string::npos;
      bool hit2 = posb != string::npos;
      string read_name;
      //j->GetTag("JW", read_name);
      
      // PROCEED IF ALIGNS TO FORWARD
      if (hit1 || hit2) {
	rr.push_back(*j);
	//int tpos = posa - pad;
	//i->addRead(*j, std::max(tpos, 0), true);
	//name_map.insert(pair<string, unsigned>(read_name, 0));
      }
      
      //OTHERWISE TRY REVERSE
      
      else {
	string rstring = QB;
	SnowUtils::rcomplement(rstring); 
	posa = m_seq.find(rstring.substr(pad,buff)); 
	posb = m_seq.find(rstring.substr(max(seqlen-buff-pad,0),buff)); 
	hit1 = posa != string::npos;
	hit2 = posb != string::npos;
	
	if (hit1 || hit2) {
	  j->EditTag("TS", "Z", rstring); // edit the tag to be reverseComplemented
	  rr.push_back(*j);
	}
      }
      ////////////////////////////
    } // end read loop
   
    } // end alignment loop

    if (rr.size() > 10000) {
      cout << "Greater than 10k reads at contig: " << m_align[0].align.Name << " with # reads: " << rr.size() << endl;
     return;
   }
   
   vector<BamAlignment> rr_name_dd, rr_pos_dd;
   SVBamReader::deduplicateReads(rr, rr_name_dd);
   SVBamReader::deduplicateReadsPos(rr_name_dd, rr_pos_dd);
   rr = rr_pos_dd;

   double mseqlen = 0;

   // set the contig strings    
   TSequence contig = m_seq;

   // set the parametersa
   int lencutoff = floor( mseqlen * 0.5 );

   // loop through the reads and do alignment
   vector<BamAlignment>::iterator it = rr.begin();
   for (; it != rr.end(); it++) {
     string read_seq;
     it->GetTag("TS", read_seq);
     double seqlen = static_cast<double>(read_seq.length());
     double cutoff = 4 * seqlen - 25; 

     if (seqlen > lencutoff) {

       // check for a 100% match, to save compute
       int32_t pos = m_seq.find(read_seq);
       int32_t score = seqlen * 4;

       // matched completely, add
       if (pos != string::npos) {
	 it->AddTag("AL", "i", pos);
	 it->AddTag("CN", "Z", m_align[0].align.Name);
	 it->AddTag("SW", "i", score);
	 m_bamreads.push_back(*it);
       // didn't match completely, SW align
       } else if (SeqanTools::SWalign(contig, pos, read_seq, score, false) > cutoff) {
	 it->AddTag("AL", "i", pos);
         it->AddTag("CN", "Z", m_align[0].align.Name);
	 it->AddTag("SW", "i", score);
	 m_bamreads.push_back(*it);
       }
	 // forwards SW didn't make it, try reverse
	 else if (SWalign(contig, true, pos, read_seq, score) > cutoff) {
	 it->AddTag("AL", "i", pos);
	 it->AddTag("CN", "Z", m_align[0].align.Name);
	 it->EditTag("TS", "Z", read_seq);
	 it->AddTag("SW", "i", score);
	 m_bamreads.push_back(*it);

	 }

     }
   
   }

}

*/
