\section{gzfilebuf Class Reference}
\label{classgzfilebuf}\index{gzfilebuf@{gzfilebuf}}
Gzipped file stream buffer class.  


{\tt \#include $<$zfstream.h$>$}

\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
int \bf{setcompression} (int comp\_\-level, int comp\_\-strategy=Z\_\-DEFAULT\_\-STRATEGY)
\begin{CompactList}\small\item\em Set compression level and strategy on the fly. \item\end{CompactList}\item 
bool \bf{is\_\-open} () const 
\begin{CompactList}\small\item\em Check if file is open. \item\end{CompactList}\item 
\bf{gzfilebuf} $\ast$ \bf{open} (const char $\ast$name, std::ios\_\-base::openmode mode)
\begin{CompactList}\small\item\em Open gzipped file. \item\end{CompactList}\item 
\bf{gzfilebuf} $\ast$ \bf{attach} (int fd, std::ios\_\-base::openmode mode)
\begin{CompactList}\small\item\em Attach to already open gzipped file. \item\end{CompactList}\item 
\bf{gzfilebuf} $\ast$ \bf{close} ()
\begin{CompactList}\small\item\em Close gzipped file. \item\end{CompactList}\end{CompactItemize}
\subsection*{Protected Member Functions}
\begin{CompactItemize}
\item 
bool \bf{open\_\-mode} (std::ios\_\-base::openmode mode, char $\ast$c\_\-mode) const 
\begin{CompactList}\small\item\em Convert ios open mode int to mode string used by zlib. \item\end{CompactList}\item 
virtual std::streamsize \bf{showmanyc} ()
\begin{CompactList}\small\item\em Number of characters available in stream buffer. \item\end{CompactList}\item 
virtual int\_\-type \bf{underflow} ()
\begin{CompactList}\small\item\em Fill get area from gzipped file. \item\end{CompactList}\item 
virtual int\_\-type \bf{overflow} (int\_\-type c=traits\_\-type::eof())
\begin{CompactList}\small\item\em Write put area to gzipped file. \item\end{CompactList}\item 
virtual std::streambuf $\ast$ \bf{setbuf} (char\_\-type $\ast$p, std::streamsize n)
\begin{CompactList}\small\item\em Installs external stream buffer. \item\end{CompactList}\item 
virtual int \bf{sync} ()
\begin{CompactList}\small\item\em Flush stream buffer to file. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Gzipped file stream buffer class. 

This class implements basic\_\-filebuf for gzipped files. It doesn't yet support seeking (allowed by zlib but slow/limited), putback and read/write access (tricky). Otherwise, it attempts to be a drop-in replacement for the standard file streambuf. 



\subsection{Member Function Documentation}
\index{gzfilebuf@{gzfilebuf}!attach@{attach}}
\index{attach@{attach}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{gzfilebuf}$\ast$ gzfilebuf::attach (int {\em fd}, std::ios\_\-base::openmode {\em mode})}\label{classgzfilebuf_4d107ba4f23910b6e1cde167952cc720}


Attach to already open gzipped file. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em fd}]File descriptor. \item[{\em mode}]Open mode flags. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt this} on success, NULL on failure. \end{Desc}
\index{gzfilebuf@{gzfilebuf}!close@{close}}
\index{close@{close}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{gzfilebuf}$\ast$ gzfilebuf::close ()}\label{classgzfilebuf_faaae237cb41538c90404653f620bfce}


Close gzipped file. 

\begin{Desc}
\item[Returns:]{\tt this} on success, NULL on failure. \end{Desc}
\index{gzfilebuf@{gzfilebuf}!is_open@{is\_\-open}}
\index{is_open@{is\_\-open}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool gzfilebuf::is\_\-open () const\hspace{0.3cm}{\tt  [inline]}}\label{classgzfilebuf_4de6e9626000c156ce4d3f09cfd1c685}


Check if file is open. 

\begin{Desc}
\item[Returns:]True if file is open. \end{Desc}
\index{gzfilebuf@{gzfilebuf}!open@{open}}
\index{open@{open}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\bf{gzfilebuf}$\ast$ gzfilebuf::open (const char $\ast$ {\em name}, std::ios\_\-base::openmode {\em mode})}\label{classgzfilebuf_737ac742dfecdcebadbd2ad769412ed1}


Open gzipped file. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em name}]File name. \item[{\em mode}]Open mode flags. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt this} on success, NULL on failure. \end{Desc}
\index{gzfilebuf@{gzfilebuf}!open_mode@{open\_\-mode}}
\index{open_mode@{open\_\-mode}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool gzfilebuf::open\_\-mode (std::ios\_\-base::openmode {\em mode}, char $\ast$ {\em c\_\-mode}) const\hspace{0.3cm}{\tt  [protected]}}\label{classgzfilebuf_dc7c3f52f432cae36a9dddd217e98e52}


Convert ios open mode int to mode string used by zlib. 

\begin{Desc}
\item[Returns:]True if valid mode flag combination. \end{Desc}
\index{gzfilebuf@{gzfilebuf}!overflow@{overflow}}
\index{overflow@{overflow}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}virtual int\_\-type gzfilebuf::overflow (int\_\-type {\em c} = {\tt traits\_\-type::eof()})\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classgzfilebuf_aa8efb73e3c98d43b8ae9c33077672ca}


Write put area to gzipped file. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em c}]Extra character to add to buffer contents. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Non-EOF on success, EOF on error.\end{Desc}
This actually writes characters in stream buffer to gzipped file. With unbuffered output this is done one character at a time. \index{gzfilebuf@{gzfilebuf}!setbuf@{setbuf}}
\index{setbuf@{setbuf}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}virtual std::streambuf$\ast$ gzfilebuf::setbuf (char\_\-type $\ast$ {\em p}, std::streamsize {\em n})\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classgzfilebuf_cb20c511ac82f7a2abfb065e03ecefb4}


Installs external stream buffer. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p}]Pointer to char buffer. \item[{\em n}]Size of external buffer. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt this} on success, NULL on failure.\end{Desc}
Call setbuf(0,0) to enable unbuffered output. \index{gzfilebuf@{gzfilebuf}!setcompression@{setcompression}}
\index{setcompression@{setcompression}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int gzfilebuf::setcompression (int {\em comp\_\-level}, int {\em comp\_\-strategy} = {\tt Z\_\-DEFAULT\_\-STRATEGY})}\label{classgzfilebuf_9b44d18d92cb81b0c712d032e84498f0}


Set compression level and strategy on the fly. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em comp\_\-level}]Compression level (see zlib.h for allowed values) \item[{\em comp\_\-strategy}]Compression strategy (see zlib.h for allowed values) \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Z\_\-OK on success, Z\_\-STREAM\_\-ERROR otherwise.\end{Desc}
Unfortunately, these parameters cannot be modified separately, as the previous zfstream version assumed. Since the strategy is seldom changed, it can default and setcompression(level) then becomes like the old setcompressionlevel(level). \index{gzfilebuf@{gzfilebuf}!showmanyc@{showmanyc}}
\index{showmanyc@{showmanyc}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}virtual std::streamsize gzfilebuf::showmanyc ()\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classgzfilebuf_297ec6d2cb06ae35ae57b2df48862f67}


Number of characters available in stream buffer. 

\begin{Desc}
\item[Returns:]Number of characters.\end{Desc}
This indicates number of characters in get area of stream buffer. These characters can be read without accessing the gzipped file. \index{gzfilebuf@{gzfilebuf}!sync@{sync}}
\index{sync@{sync}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}virtual int gzfilebuf::sync ()\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classgzfilebuf_170bf1bb08797eb922301d6b90fa95e4}


Flush stream buffer to file. 

\begin{Desc}
\item[Returns:]0 on success, -1 on error.\end{Desc}
This calls underflow(EOF) to do the job. \index{gzfilebuf@{gzfilebuf}!underflow@{underflow}}
\index{underflow@{underflow}!gzfilebuf@{gzfilebuf}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}virtual int\_\-type gzfilebuf::underflow ()\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classgzfilebuf_e3223d74f44ca4a29052a14f488821fd}


Fill get area from gzipped file. 

\begin{Desc}
\item[Returns:]First character in get area on success, EOF on error.\end{Desc}
This actually reads characters from gzipped file to stream buffer. Always buffered. 

The documentation for this class was generated from the following file:\begin{CompactItemize}
\item 
/xchip/gistic/Jeremiah/GIT/Snowman\-SV/src/Snowman/zfstream.h\end{CompactItemize}
